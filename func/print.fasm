cur dw 0
hex_table db '0123456789ABCDEF'

macro print _type, _data
{	
	mov byte [a1], _type
	mov [a2], _data
	call f_print
}

f_print:
	pushf
	push eax ebx ecx esi

.main:
	cmp byte [a1], 1
	jne @f
	call .sumbol
@@:
	cmp byte [a1], 2
	jne @f 
	call .string
@@:
	cmp byte [a1], 3
	jne @f 
	call ._byte
@@:

.return:
	pop esi ecx ebx eax
	popf
	ret

.sumbol:
	mov bx, word [cur]
	push word [a2]       ; читаем байт и цвет из аргумента
	pop word [es:bx]     ; записываем байт и цвет в буффер экрана
	add word [cur], 2    ; переходим к следущему байту буффера экрана
	ret

.string:
	mov esi, dword [a2]  ; читаем аргумент - адрес
	mov ah, byte [esi]   ; читаем первый байт - цвет
	mov byte [a2+1], ah  ; записываем цвет в аргумент для подфункции
	inc esi
.string_loop:
	mov al, byte [esi]   ; читаем байт из строки
	inc esi              ; переходим к следущему байту строки

	cmp al, 0            ; если байт = 0, то выходим
	je .string_end

	mov byte [a2], al    ; записываем байт в аргумент для подфункции
	call .sumbol         ; вызываем подфункцию

	jmp .string_loop
.string_end:
	ret

._byte:
	mov ah, 0
	mov al, byte [a2]
	mov bl, 16
	div bl
	movzx esi, al
	mov al, byte [hex_table+esi]
	movzx esi, ah
	mov ah, byte [hex_table+esi]
	
	mov byte [a2], al
	call .sumbol
	mov byte [a2], ah
	call .sumbol
	ret